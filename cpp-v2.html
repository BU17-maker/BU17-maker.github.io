<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++模板 - 我的工具箱</title>
    <link rel="stylesheet" href="style-v2.css">
</head>
<body>
    <div id="navbar-container"></div>
    
    <main class="container">
        <header class="page-header">
            <h1>C++ 模板库</h1>
            <p class="subtitle">竞赛常用代码模板</p>
        </header>

        <div class="search-bar">
            <input type="text" id="template-search" placeholder="搜索模板..." />
            <select id="category-filter">
                <option value="all">全部分类</option>
                <option value="basic">基础模板</option>
                <option value="data-struct">数据结构</option>
                <option value="graph">图论</option>
                <option value="dp">动态规划</option>
                <option value="math">数学</option>
                <option value="string">字符串</option>
            </select>
        </div>

        <div class="templates-grid">
            <!-- 基础模板 -->
            <div class="template-card" data-category="basic">
                <div class="template-header">
                    <h3>快速读写模板</h3>
                    <span class="template-tag">基础</span>
                </div>
                <div class="template-content">
                    <pre><code>namespace io {
    const int SIZE = 1 << 20;
    char buf[SIZE], *p1 = buf, *p2 = buf;
    #define gc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, SIZE, stdin), p1 == p2) ? EOF : *p1++)
    
    inline int read() {
        int x = 0, f = 1; char c = gc();
        while (c < '0' || c > '9') { if (c == '-') f = -1; c = gc(); }
        while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = gc();
        return x * f;
    }
}</code></pre>
                </div>
                <div class="template-footer">
                    <button class="btn-copy" onclick="copyCode(this)">复制代码</button>
                    <span class="template-desc">适用于大数据量输入输出优化</span>
                </div>
            </div>

            <div class="template-card" data-category="basic">
                <div class="template-header">
                    <h3>常用宏定义</h3>
                    <span class="template-tag">基础</span>
                </div>
                <div class="template-content">
                    <pre><code>#include <bits/stdc++.h>
using namespace std;

#define FOR(i, a, b) for (int i = (a); i <= (b); i++)
#define ROF(i, a, b) for (int i = (a); i >= (b); i--)
#define REP(i, n) for (int i = 0; i < (n); i++)
#define ll long long
#define ull unsigned long long
#define pii pair<int, int>
#define pll pair<ll, ll>
#define pb push_back
#define eb emplace_back
#define fi first
#define se second
#define all(v) v.begin(), v.end()</code></pre>
                </div>
                <div class="template-footer">
                    <button class="btn-copy" onclick="copyCode(this)">复制代码</button>
                    <span class="template-desc">竞赛常用宏定义集合</span>
                </div>
            </div>

            <!-- 数据结构 -->
            <div class="template-card" data-category="data-struct">
                <div class="template-header">
                    <h3>并查集</h3>
                    <span class="template-tag">数据结构</span>
                </div>
                <div class="template-content">
                    <pre><code>struct DSU {
    vector<int> fa, sz;
    
    DSU(int n) : fa(n), sz(n, 1) {
        iota(fa.begin(), fa.end(), 0);
    }
    
    int find(int x) {
        return fa[x] == x ? x : fa[x] = find(fa[x]);
    }
    
    bool unite(int x, int y) {
        x = find(x), y = find(y);
        if (x == y) return false;
        if (sz[x] < sz[y]) swap(x, y);
        fa[y] = x;
        sz[x] += sz[y];
        return true;
    }
    
    bool same(int x, int y) {
        return find(x) == find(y);
    }
};</code></pre>
                </div>
                <div class="template-footer">
                    <button class="btn-copy" onclick="copyCode(this)">复制代码</button>
                    <span class="template-desc">带路径压缩和按秩合并</span>
                </div>
            </div>

            <div class="template-card" data-category="data-struct">
                <div class="template-header">
                    <h3>线段树</h3>
                    <span class="template-tag">数据结构</span>
                </div>
                <div class="template-content">
                    <pre><code>struct SegTree {
    struct Node {
        ll sum, lazy;
        Node() : sum(0), lazy(0) {}
    };
    
    int n;
    vector<Node> tree;
    
    SegTree(int n) : n(n), tree(n * 4) {}
    
    void push_down(int p, int l, int r) {
        if (tree[p].lazy) {
            int mid = (l + r) >> 1;
            tree[p*2].sum += tree[p].lazy * (mid - l + 1);
            tree[p*2+1].sum += tree[p].lazy * (r - mid);
            tree[p*2].lazy += tree[p].lazy;
            tree[p*2+1].lazy += tree[p].lazy;
            tree[p].lazy = 0;
        }
    }
    
    void update(int p, int l, int r, int L, int R, ll val) {
        if (L <= l && r <= R) {
            tree[p].sum += val * (r - l + 1);
            tree[p].lazy += val;
            return;
        }
        push_down(p, l, r);
        int mid = (l + r) >> 1;
        if (L <= mid) update(p*2, l, mid, L, R, val);
        if (R > mid) update(p*2+1, mid+1, r, L, R, val);
        tree[p].sum = tree[p*2].sum + tree[p*2+1].sum;
    }
    
    ll query(int p, int l, int r, int L, int R) {
        if (L <= l && r <= R) return tree[p].sum;
        push_down(p, l, r);
        int mid = (l + r) >> 1;
        ll res = 0;
        if (L <= mid) res += query(p*2, l, mid, L, R);
        if (R > mid) res += query(p*2+1, mid+1, r, L, R);
        return res;
    }
};</code></pre>
                </div>
                <div class="template-footer">
                    <button class="btn-copy" onclick="copyCode(this)">复制代码</button>
                    <span class="template-desc">区间更新和区间查询</span>
                </div>
            </div>

            <!-- 图论 -->
            <div class="template-card" data-category="graph">
                <div class="template-header">
                    <h3>Dijkstra算法</h3>
                    <span class="template-tag">图论</span>
                </div>
                <div class="template-content">
                    <pre><code>vector<ll> dijkstra(int s, const vector<vector<pii>>& g) {
    int n = g.size();
    vector<ll> dis(n, LLONG_MAX);
    vector<bool> vis(n, false);
    priority_queue<pll, vector<pll>, greater<pll>> pq;
    
    dis[s] = 0;
    pq.push({0, s});
    
    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();
        
        if (vis[u]) continue;
        vis[u] = true;
        
        for (auto [v, w] : g[u]) {
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                pq.push({dis[v], v});
            }
        }
    }
    return dis;
}</code></pre>
                </div>
                <div class="template-footer">
                    <button class="btn-copy" onclick="copyCode(this)">复制代码</button>
                    <span class="template-desc">单源最短路径，支持负权</span>
                </div>
            </div>

            <div class="template-card" data-category="graph">
                <div class="template-header">
                    <h3>SPFA算法</h3>
                    <span class="template-tag">图论</span>
                </div>
                <div class="template-content">
                    <pre><code>bool spfa(int s, const vector<vector<pii>>& g, vector<ll>& dis) {
    int n = g.size();
    dis.assign(n, LLONG_MAX);
    vector<int> cnt(n, 0);
    vector<bool> inq(n, false);
    queue<int> q;
    
    dis[s] = 0;
    q.push(s);
    inq[s] = true;
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        inq[u] = false;
        
        for (auto [v, w] : g[u]) {
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                if (!inq[v]) {
                    q.push(v);
                    inq[v] = true;
                    if (++cnt[v] > n) return false; // 存在负环
                }
            }
        }
    }
    return true;
}</code></pre>
                </div>
                <div class="template-footer">
                    <button class="btn-copy" onclick="copyCode(this)">复制代码</button>
                    <span class="template-desc">可检测负环的最短路算法</span>
                </div>
            </div>

            <!-- 动态规划 -->
            <div class="template-card" data-category="dp">
                <div class="template-header">
                    <h3>01背包</h3>
                    <span class="template-tag">DP</span>
                </div>
                <div class="template-content">
                    <pre><code>int knapsack01(int W, const vector<int>& wt, const vector<int>& val) {
    int n = wt.size();
    vector<vector<int>> dp(n + 1, vector<int>(W + 1, 0));
    
    for (int i = 1; i <= n; i++) {
        for (int w = 0; w <= W; w++) {
            if (wt[i-1] <= w) {
                dp[i][w] = max(dp[i-1][w], dp[i-1][w - wt[i-1]] + val[i-1]);
            } else {
                dp[i][w] = dp[i-1][w];
            }
        }
    }
    return dp[n][W];
}

// 空间优化版本
int knapsack01_optimized(int W, const vector<int>& wt, const vector<int>& val) {
    int n = wt.size();
    vector<int> dp(W + 1, 0);
    
    for (int i = 0; i < n; i++) {
        for (int w = W; w >= wt[i]; w--) {
            dp[w] = max(dp[w], dp[w - wt[i]] + val[i]);
        }
    }
    return dp[W];
}</code></pre>
                </div>
                <div class="template-footer">
                    <button class="btn-copy" onclick="copyCode(this)">复制代码</button>
                    <span class="template-desc">经典01背包问题解法</span>
                </div>
            </div>

            <!-- 数学 -->
            <div class="template-card" data-category="math">
                <div class="template-header">
                    <h3>快速幂</h3>
                    <span class="template-tag">数学</span>
                </div>
                <div class="template-content">
                    <pre><code>ll qpow(ll a, ll b, ll mod) {
    ll res = 1;
    a %= mod;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

ll qpow(ll a, ll b) {  // 无模数版本
    ll res = 1;
    while (b) {
        if (b & 1) res *= a;
        a *= a;
        b >>= 1;
    }
    return res;
}</code></pre>
                </div>
                <div class="template-footer">
                    <button class="btn-copy" onclick="copyCode(this)">复制代码</button>
                    <span class="template-desc">O(logn)时间复杂度的幂运算</span>
                </div>
            </div>

            <div class="template-card" data-category="math">
                <div class="template-header">
                    <h3>线性筛</h3>
                    <span class="template-tag">数学</span>
                </div>
                <div class="template-content">
                    <pre><code>vector<int> linear_sieve(int n) {
    vector<int> primes, is_prime(n + 1, 1), min_factor(n + 1);
    
    for (int i = 2; i <= n; i++) {
        if (is_prime[i]) {
            primes.push_back(i);
            min_factor[i] = i;
        }
        for (int p : primes) {
            if (i * p > n) break;
            is_prime[i * p] = 0;
            min_factor[i * p] = p;
            if (i % p == 0) break;
        }
    }
    return primes;  // 或者返回is_prime
}</code></pre>
                </div>
                <div class="template-footer">
                    <button class="btn-copy" onclick="copyCode(this)">复制代码</button>
                    <span class="template-desc">O(n)时间筛素数</span>
                </div>
            </div>

            <!-- 字符串 -->
            <div class="template-card" data-category="string">
                <div class="template-header">
                    <h3>KMP算法</h3>
                    <span class="template-tag">字符串</span>
                </div>
                <div class="template-content">
                    <pre><code>vector<int> kmp_next(const string& s) {
    int n = s.size();
    vector<int> nxt(n);
    
    for (int i = 1, j = 0; i < n; i++) {
        while (j && s[i] != s[j]) j = nxt[j - 1];
        if (s[i] == s[j]) nxt[i] = ++j;
        else nxt[i] = 0;
    }
    return nxt;
}

vector<int> kmp_search(const string& s, const string& p) {
    vector<int> nxt = kmp_next(p);
    vector<int> res;
    
    for (int i = 0, j = 0; i < s.size(); i++) {
        while (j && s[i] != p[j]) j = nxt[j - 1];
        if (s[i] == p[j]) j++;
        if (j == p.size()) {
            res.push_back(i - j + 1);
            j = nxt[j - 1];
        }
    }
    return res;
}</code></pre>
                </div>
                <div class="template-footer">
                    <button class="btn-copy" onclick="copyCode(this)">复制代码</button>
                    <span class="template-desc">字符串匹配算法</span>
                </div>
            </div>
        </div>
    </main>

    <script src="main-v2.js"></script>
</body>
</html>